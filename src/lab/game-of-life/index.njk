---
layout: base.njk
title: "Game of Life"
---
<a href="{{ '/lab/' | url }}" class="back">← lab</a>
<article>
  <header>
    <time>эксперимент 002</time>
    <h1>Game of Life</h1>
  </header>
  <div class="content">
    <p>Конвей, 1970. Четыре правила, бесконечная сложность. Рисуйте мышью, выбирайте паттерны, наблюдайте за эволюцией.</p>

    <div class="lab-controls">
      <div class="lab-row">
        <button id="btn-play" class="active">▶ старт</button>
        <button id="btn-step">шаг</button>
        <button id="btn-clear">очистить</button>
        <button id="btn-random">случайный</button>
      </div>
      <div class="lab-row">
        <label for="speed">скорость</label>
        <input type="range" id="speed" min="1" max="60" value="12">
        <span id="speed-val" style="font-family:var(--mono);font-size:0.8rem;color:var(--text-dim);min-width:40px">12 fps</span>
      </div>
      <div class="lab-row">
        <label>паттерны</label>
        <button class="preset-btn" data-preset="glider">glider</button>
        <button class="preset-btn" data-preset="lwss">LWSS</button>
        <button class="preset-btn" data-preset="pulsar">pulsar</button>
        <button class="preset-btn" data-preset="gosper">gosper gun</button>
      </div>
    </div>

    <div class="lab-stats" id="stats">
      <span>поколение: <strong id="gen-count">0</strong></span>
      <span>клетки: <strong id="cell-count">0</strong></span>
    </div>

    <canvas id="gol-canvas"></canvas>

    <h2>Правила</h2>
    <p>Каждая клетка на бесконечной сетке — живая или мёртвая. На каждом шаге:</p>
    <ul>
      <li><strong>Выживание:</strong> живая клетка с 2 или 3 соседями остаётся живой</li>
      <li><strong>Смерть от одиночества:</strong> живая клетка с менее чем 2 соседями умирает</li>
      <li><strong>Смерть от перенаселения:</strong> живая клетка с более чем 3 соседями умирает</li>
      <li><strong>Рождение:</strong> мёртвая клетка с ровно 3 соседями оживает</li>
    </ul>
    <p>Из этих четырёх правил возникают глайдеры, осцилляторы, пушки и структуры, способные вычислять — Game of Life является Тьюринг-полной системой.</p>
  </div>
</article>

<style>
  .lab-controls {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 20px;
    margin: 24px 0;
  }
  .lab-row {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
    flex-wrap: wrap;
  }
  .lab-row:last-child { margin-bottom: 0; }
  .lab-row label {
    font-family: var(--mono);
    font-size: 0.8rem;
    color: var(--text-dim);
    min-width: 60px;
  }
  .lab-row input[type="range"] {
    flex: 1;
    max-width: 200px;
    accent-color: var(--accent);
  }
  .lab-row button, .preset-btn {
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--text-dim);
    font-family: var(--mono);
    font-size: 0.8rem;
    padding: 6px 14px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
  }
  .lab-row button:hover, .preset-btn:hover {
    border-color: var(--accent);
    color: var(--accent);
  }
  .lab-row button.active {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(123, 140, 222, 0.1);
  }
  #btn-play {
    min-width: 90px;
  }
  .lab-stats {
    display: flex;
    gap: 24px;
    font-family: var(--mono);
    font-size: 0.8rem;
    color: var(--text-dim);
    margin-bottom: 8px;
  }
  #gol-canvas {
    width: 100%;
    border: 1px solid var(--border);
    border-radius: 8px;
    margin: 8px 0 24px;
    background: var(--bg);
    cursor: crosshair;
    image-rendering: pixelated;
  }
</style>

<script>
(function() {
  const canvas = document.getElementById('gol-canvas');
  const ctx = canvas.getContext('2d');
  const genEl = document.getElementById('gen-count');
  const cellEl = document.getElementById('cell-count');
  const speedInput = document.getElementById('speed');
  const speedVal = document.getElementById('speed-val');

  const CELL = 6;
  let cols, rows;
  let grid, nextGrid;
  let running = false;
  let generation = 0;
  let animId = null;
  let lastTime = 0;
  let fps = 12;
  let drawing = false;
  let drawValue = 1;

  const BG = [10, 10, 15];
  const ALIVE = [123, 140, 222];
  const GRID_LINE = [30, 30, 46];

  function init() {
    cols = Math.floor(canvas.clientWidth / CELL);
    rows = Math.floor(cols * 0.6);
    canvas.width = cols * CELL;
    canvas.height = rows * CELL;
    canvas.style.height = canvas.height + 'px';
    grid = new Uint8Array(cols * rows);
    nextGrid = new Uint8Array(cols * rows);
    generation = 0;
  }

  function idx(x, y) {
    return ((y + rows) % rows) * cols + ((x + cols) % cols);
  }

  function countNeighbors(x, y) {
    let count = 0;
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        count += grid[idx(x + dx, y + dy)];
      }
    }
    return count;
  }

  function step() {
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const i = y * cols + x;
        const n = countNeighbors(x, y);
        if (grid[i]) {
          nextGrid[i] = (n === 2 || n === 3) ? 1 : 0;
        } else {
          nextGrid[i] = (n === 3) ? 1 : 0;
        }
      }
    }
    var tmp = grid;
    grid = nextGrid;
    nextGrid = tmp;
    generation++;
  }

  function render() {
    var imageData = ctx.createImageData(cols * CELL, rows * CELL);
    var data = imageData.data;

    for (var py = 0; py < rows * CELL; py++) {
      for (var px = 0; px < cols * CELL; px++) {
        var off = (py * cols * CELL + px) * 4;
        var cx = Math.floor(px / CELL);
        var cy = Math.floor(py / CELL);
        var isEdge = (px % CELL === 0) || (py % CELL === 0);

        if (grid[cy * cols + cx]) {
          data[off] = ALIVE[0];
          data[off+1] = ALIVE[1];
          data[off+2] = ALIVE[2];
        } else if (isEdge) {
          data[off] = GRID_LINE[0];
          data[off+1] = GRID_LINE[1];
          data[off+2] = GRID_LINE[2];
        } else {
          data[off] = BG[0];
          data[off+1] = BG[1];
          data[off+2] = BG[2];
        }
        data[off+3] = 255;
      }
    }

    ctx.putImageData(imageData, 0, 0);
    genEl.textContent = generation;
    cellEl.textContent = grid.reduce(function(a,b){return a+b;}, 0);
  }

  function loop(time) {
    if (!running) return;
    animId = requestAnimationFrame(loop);
    if (time - lastTime < 1000 / fps) return;
    lastTime = time;
    step();
    render();
  }

  function togglePlay() {
    running = !running;
    var btn = document.getElementById('btn-play');
    if (running) {
      btn.textContent = '⏸ пауза';
      btn.classList.add('active');
      lastTime = 0;
      animId = requestAnimationFrame(loop);
    } else {
      btn.textContent = '▶ старт';
      btn.classList.remove('active');
      if (animId) cancelAnimationFrame(animId);
    }
  }

  function getCellFromEvent(e) {
    var rect = canvas.getBoundingClientRect();
    var scaleX = canvas.width / rect.width;
    var scaleY = canvas.height / rect.height;
    var x = Math.floor((e.clientX - rect.left) * scaleX / CELL);
    var y = Math.floor((e.clientY - rect.top) * scaleY / CELL);
    return {x: Math.min(Math.max(x, 0), cols-1), y: Math.min(Math.max(y, 0), rows-1)};
  }

  canvas.addEventListener('mousedown', function(e) {
    e.preventDefault();
    drawing = true;
    var c = getCellFromEvent(e);
    drawValue = grid[c.y * cols + c.x] ? 0 : 1;
    grid[c.y * cols + c.x] = drawValue;
    render();
  });

  canvas.addEventListener('mousemove', function(e) {
    if (!drawing) return;
    var c = getCellFromEvent(e);
    grid[c.y * cols + c.x] = drawValue;
    if (!running) render();
  });

  window.addEventListener('mouseup', function() { drawing = false; });

  canvas.addEventListener('touchstart', function(e) {
    e.preventDefault();
    drawing = true;
    var touch = e.touches[0];
    var c = getCellFromEvent(touch);
    drawValue = grid[c.y * cols + c.x] ? 0 : 1;
    grid[c.y * cols + c.x] = drawValue;
    render();
  });

  canvas.addEventListener('touchmove', function(e) {
    e.preventDefault();
    if (!drawing) return;
    var touch = e.touches[0];
    var c = getCellFromEvent(touch);
    grid[c.y * cols + c.x] = drawValue;
    if (!running) render();
  });

  canvas.addEventListener('touchend', function() { drawing = false; });

  document.getElementById('btn-play').addEventListener('click', togglePlay);

  document.getElementById('btn-step').addEventListener('click', function() {
    if (running) togglePlay();
    step();
    render();
  });

  document.getElementById('btn-clear').addEventListener('click', function() {
    if (running) togglePlay();
    grid.fill(0);
    generation = 0;
    render();
  });

  document.getElementById('btn-random').addEventListener('click', function() {
    for (var i = 0; i < grid.length; i++) {
      grid[i] = Math.random() < 0.3 ? 1 : 0;
    }
    generation = 0;
    render();
    if (!running) togglePlay();
  });

  speedInput.addEventListener('input', function() {
    fps = parseInt(this.value);
    speedVal.textContent = fps + ' fps';
  });

  // Presets
  var presets = {
    glider: function(ox, oy) {
      var cells = [[1,0],[2,1],[0,2],[1,2],[2,2]];
      cells.forEach(function(c) { grid[idx(ox+c[0], oy+c[1])] = 1; });
    },
    lwss: function(ox, oy) {
      var cells = [[1,0],[4,0],[0,1],[0,2],[4,2],[0,3],[1,3],[2,3],[3,3]];
      cells.forEach(function(c) { grid[idx(ox+c[0], oy+c[1])] = 1; });
    },
    pulsar: function(ox, oy) {
      var quarter = [[2,0],[3,0],[4,0],[0,2],[0,3],[0,4],[5,2],[5,3],[5,4],[2,5],[3,5],[4,5]];
      quarter.forEach(function(c) {
        grid[idx(ox+c[0], oy+c[1])] = 1;
        grid[idx(ox-c[0], oy+c[1])] = 1;
        grid[idx(ox+c[0], oy-c[1])] = 1;
        grid[idx(ox-c[0], oy-c[1])] = 1;
      });
    },
    gosper: function(ox, oy) {
      var cells = [
        [0,4],[0,5],[1,4],[1,5],
        [10,3],[10,4],[10,5],[11,2],[11,6],[12,1],[12,7],[13,1],[13,7],
        [14,4],[15,2],[15,6],[16,3],[16,4],[16,5],[17,4],
        [20,1],[20,2],[20,3],[21,1],[21,2],[21,3],[22,0],[22,4],
        [24,0],[24,-1],[24,4],[24,5],
        [34,2],[34,3],[35,2],[35,3]
      ];
      cells.forEach(function(c) { grid[idx(ox+c[0], oy+c[1])] = 1; });
    }
  };

  document.querySelectorAll('.preset-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
      if (running) togglePlay();
      grid.fill(0);
      generation = 0;
      var name = this.dataset.preset;
      var ox = Math.floor(cols / 2) - 15;
      var oy = Math.floor(rows / 2) - 5;
      if (name === 'glider') { ox = 5; oy = 5; }
      if (name === 'lwss') { ox = 5; oy = Math.floor(rows/2); }
      presets[name](ox, oy);
      render();
    });
  });

  init();
  render();
})();
</script>
